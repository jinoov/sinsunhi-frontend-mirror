// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as React from "react";
import * as IconError from "../../components/svgs/IconError.mjs";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Js_promise from "rescript/lib/es6/js_promise.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Router from "next/router";
import * as ReactRelay from "react-relay";
import * as DeviceDetect from "../../bindings/DeviceDetect.mjs";
import * as Footer_Buyer from "../../components/Footer_Buyer.mjs";
import * as Header_Buyer from "../../components/Header_Buyer.mjs";
import * as Authorization from "../../utils/Authorization.mjs";
import * as ReactHookForm from "../../bindings/ReactHookForm/ReactHookForm.mjs";
import * as RescriptRelay from "rescript-relay/src/RescriptRelay.mjs";
import * as RelayRuntime from "relay-runtime";
import * as Cart_Buyer_Form from "../../components/Cart_Buyer_Form.mjs";
import * as Cart_Buyer_Item from "../../components/Cart_Buyer_Item.mjs";
import * as Cart_Buyer_Util from "../../components/Cart_Buyer_Util.mjs";
import * as ReactHookForm$1 from "react-hook-form";
import * as ToggleOrderAndPayment from "../../utils/ToggleOrderAndPayment.mjs";
import * as CartBuyerQuery_graphql from "../../__generated__/CartBuyerQuery_graphql.mjs";
import * as RescriptRelay_Internal from "rescript-relay/src/RescriptRelay_Internal.mjs";
import * as CartBuyerMutation_graphql from "../../__generated__/CartBuyerMutation_graphql.mjs";
import * as ReactToastNotifications from "react-toast-notifications";

function use(variables, fetchPolicy, fetchKey, networkCacheConfig, param) {
  var data = ReactRelay.useLazyLoadQuery(CartBuyerQuery_graphql.node, RescriptRelay_Internal.internal_cleanObjectFromUndefinedRaw(CartBuyerQuery_graphql.Internal.convertVariables(variables)), {
        fetchKey: fetchKey,
        fetchPolicy: RescriptRelay.mapFetchPolicy(fetchPolicy),
        networkCacheConfig: networkCacheConfig
      });
  return RescriptRelay_Internal.internal_useConvertedValue(CartBuyerQuery_graphql.Internal.convertResponse, data);
}

function useLoader(param) {
  var match = ReactRelay.useQueryLoader(CartBuyerQuery_graphql.node);
  var loadQueryFn = match[1];
  var loadQuery = React.useMemo((function () {
          return function (param, param$1, param$2, param$3) {
            return Curry._2(loadQueryFn, CartBuyerQuery_graphql.Internal.convertVariables(param), {
                        fetchPolicy: param$1,
                        networkCacheConfig: param$2
                      });
          };
        }), [loadQueryFn]);
  return [
          Caml_option.nullable_to_opt(match[0]),
          loadQuery,
          match[2]
        ];
}

function $$fetch(environment, variables, onResult, networkCacheConfig, fetchPolicy, param) {
  ReactRelay.fetchQuery(environment, CartBuyerQuery_graphql.node, CartBuyerQuery_graphql.Internal.convertVariables(variables), {
          networkCacheConfig: networkCacheConfig,
          fetchPolicy: RescriptRelay.mapFetchQueryFetchPolicy(fetchPolicy)
        }).subscribe({
        next: (function (res) {
            Curry._1(onResult, {
                  TAG: /* Ok */0,
                  _0: CartBuyerQuery_graphql.Internal.convertResponse(res)
                });
          }),
        error: (function (err) {
            Curry._1(onResult, {
                  TAG: /* Error */1,
                  _0: err
                });
          })
      });
}

function fetchPromised(environment, variables, networkCacheConfig, fetchPolicy, param) {
  var __x = ReactRelay.fetchQuery(environment, CartBuyerQuery_graphql.node, CartBuyerQuery_graphql.Internal.convertVariables(variables), {
          networkCacheConfig: networkCacheConfig,
          fetchPolicy: RescriptRelay.mapFetchQueryFetchPolicy(fetchPolicy)
        }).toPromise();
  return Js_promise.then_((function (res) {
                return Promise.resolve(CartBuyerQuery_graphql.Internal.convertResponse(res));
              }), __x);
}

function usePreloaded(queryRef, param) {
  var data = ReactRelay.usePreloadedQuery(CartBuyerQuery_graphql.node, queryRef);
  return RescriptRelay_Internal.internal_useConvertedValue(CartBuyerQuery_graphql.Internal.convertResponse, data);
}

function retain(environment, variables) {
  var operationDescriptor = RelayRuntime.createOperationDescriptor(CartBuyerQuery_graphql.node, CartBuyerQuery_graphql.Internal.convertVariables(variables));
  return environment.retain(operationDescriptor);
}

var Query = {
  Operation: undefined,
  Types: undefined,
  use: use,
  useLoader: useLoader,
  $$fetch: $$fetch,
  fetchPromised: fetchPromised,
  usePreloaded: usePreloaded,
  retain: retain
};

function commitMutation(environment, variables, optimisticUpdater, optimisticResponse, updater, onCompleted, onError, uploadables, param) {
  return RelayRuntime.commitMutation(environment, {
              mutation: CartBuyerMutation_graphql.node,
              variables: CartBuyerMutation_graphql.Internal.convertVariables(variables),
              onCompleted: (function (res, err) {
                  if (onCompleted !== undefined) {
                    return Curry._2(onCompleted, CartBuyerMutation_graphql.Internal.convertResponse(res), (err == null) ? undefined : Caml_option.some(err));
                  }
                  
                }),
              onError: (function (err) {
                  if (onError !== undefined) {
                    return Curry._1(onError, (err == null) ? undefined : Caml_option.some(err));
                  }
                  
                }),
              optimisticResponse: optimisticResponse !== undefined ? CartBuyerMutation_graphql.Internal.convertWrapRawResponse(optimisticResponse) : undefined,
              optimisticUpdater: optimisticUpdater,
              updater: updater !== undefined ? (function (store, r) {
                    Curry._2(updater, store, CartBuyerMutation_graphql.Internal.convertResponse(r));
                  }) : undefined,
              uploadables: uploadables
            });
}

function use$1(param) {
  var match = ReactRelay.useMutation(CartBuyerMutation_graphql.node);
  var mutate = match[0];
  return [
          React.useMemo((function () {
                  return function (param, param$1, param$2, param$3, param$4, param$5, param$6, param$7, param$8) {
                    return Curry._1(mutate, {
                                onError: param,
                                onCompleted: param$1 !== undefined ? (function (r, errors) {
                                      Curry._2(param$1, CartBuyerMutation_graphql.Internal.convertResponse(r), (errors == null) ? undefined : Caml_option.some(errors));
                                    }) : undefined,
                                onUnsubscribe: param$2,
                                optimisticResponse: param$3 !== undefined ? CartBuyerMutation_graphql.Internal.convertWrapRawResponse(param$3) : undefined,
                                optimisticUpdater: param$4,
                                updater: param$5 !== undefined ? (function (store, r) {
                                      Curry._2(param$5, store, CartBuyerMutation_graphql.Internal.convertResponse(r));
                                    }) : undefined,
                                variables: CartBuyerMutation_graphql.Internal.convertVariables(param$6),
                                uploadables: param$7
                              });
                  };
                }), [mutate]),
          match[1]
        ];
}

var Mutation = {
  Operation: undefined,
  Types: undefined,
  commitMutation: commitMutation,
  use: use$1
};

function Cart_Buyer$Container(Props) {
  var deviceType = Props.deviceType;
  var match = ReactToastNotifications.useToasts();
  var addToast = match.addToast;
  var router = Router.useRouter();
  var availableButton = ToggleOrderAndPayment.use(undefined);
  var methods = ReactHookForm$1.useForm({
        mode: "all",
        shouldUnregister: true
      }, undefined);
  var match$1 = React.useState(function () {
        return false;
      });
  var match$2 = use$1(undefined);
  var mutate = match$2[0];
  var query = use(undefined, /* NetworkOnly */3, undefined, undefined, undefined);
  var handleError = function (message, param) {
    addToast(React.createElement("div", {
              className: "flex items-center"
            }, React.createElement(IconError.make, {
                  width: "24",
                  height: "24",
                  className: "mr-2"
                }), "주문에 실패하였습니다. " + Belt_Option.getWithDefault(message, "") + ""), {
          appearance: "error"
        });
  };
  var extractCartIds = function (e) {
    return Belt_Array.concatMany(Belt_Array.map(Belt_Array.keep(Belt_Option.getWithDefault(e.cartItems, []), (function (cartItem) {
                          return Cart_Buyer_Form.soldable(cartItem.productStatus);
                        })), (function (cartItem) {
                      return Belt_Array.map(Belt_Array.keep(cartItem.productOptions, (function (option) {
                                        if (option.checked) {
                                          return Cart_Buyer_Form.soldable(option.optionStatus);
                                        } else {
                                          return false;
                                        }
                                      })), (function (option) {
                                    return option.cartId;
                                  }));
                    })));
  };
  var onSubmit = function (data, param) {
    if (availableButton) {
      var err = Cart_Buyer_Form.submit_decode(data);
      if (err.TAG === /* Ok */0) {
        var cart = err._0.cart;
        var match = cart.orderType;
        var match$1 = match === "UnCourierAvailable" ? [
            extractCartIds(cart.unCourierAvailableItem),
            Belt_Option.getWithDefault(cart.unCourierAvailableItem.cartItems, [])
          ] : [
            extractCartIds(cart.courierAvailableItem),
            Belt_Option.getWithDefault(cart.courierAvailableItem.cartItems, [])
          ];
        var cartItems = match$1[1];
        var cartIds = match$1[0];
        Curry.app(mutate, [
              (function (err) {
                  handleError(err.message, undefined);
                }),
              (function (param, param$1) {
                  var createTempWosOrder = param.createTempWosOrder;
                  if (createTempWosOrder !== undefined) {
                    if (typeof createTempWosOrder !== "object") {
                      return handleError(undefined, undefined);
                    }
                    var variant = createTempWosOrder.NAME;
                    if (variant === "CartError") {
                      return handleError(Belt_Option.getWithDefault(createTempWosOrder.VAL.message, ""), undefined);
                    }
                    if (variant !== "TempWosOrder") {
                      if (variant === "Error") {
                        return handleError(Belt_Option.getWithDefault(createTempWosOrder.VAL.message, ""), undefined);
                      } else {
                        return handleError(undefined, undefined);
                      }
                    }
                    Cart_Buyer_Form.cartGtmPush(cartItems, cartIds, "begin_checkout");
                    var prim1 = "/buyer/web-order/" + String(createTempWosOrder.VAL.tempOrderId) + "";
                    router.push(prim1);
                    return ;
                  }
                  console.log("fail to mutation");
                }),
              undefined,
              undefined,
              undefined,
              undefined,
              {
                cartItems: cartIds
              },
              undefined,
              undefined
            ]);
        return ;
      }
      console.log(err._0);
      return ;
    }
    window.alert("서비스 점검으로 인해 주문,결제 기능을 이용할 수 없습니다.");
  };
  var tmp;
  switch (deviceType) {
    case /* Unknown */0 :
        tmp = null;
        break;
    case /* PC */1 :
        tmp = React.createElement(React.Fragment, undefined, React.createElement(Header_Buyer.PC_Old.make, {
                  key: router.asPath
                }), React.createElement(Cart_Buyer_Item.make, {
                  query: query.fragmentRefs,
                  deviceType: deviceType
                }), React.createElement(Footer_Buyer.PC.make, {}));
        break;
    case /* Mobile */2 :
        tmp = React.createElement(React.Fragment, undefined, React.createElement(Header_Buyer.Mobile.make, {}), React.createElement(Cart_Buyer_Item.make, {
                  query: query.fragmentRefs,
                  deviceType: deviceType
                }));
        break;
    
  }
  return React.createElement(React.Fragment, undefined, React.createElement(ReactHookForm.Provider.make, {
                  children: React.createElement("form", {
                        onSubmit: methods.handleSubmit(onSubmit)
                      }, tmp),
                  methods: methods
                }), React.createElement(Cart_Buyer_Util.SubmitDialog.make, {
                  open: match$1[0],
                  setOpen: match$1[1]
                }));
}

var Container = {
  make: Cart_Buyer$Container
};

function $$default(props) {
  var deviceType = props.deviceType;
  return React.createElement(Authorization.Buyer.make, {
              children: React.createElement(React.Suspense, {
                    children: React.createElement(Cart_Buyer$Container, {
                          deviceType: deviceType
                        }),
                    fallback: React.createElement(Cart_Buyer_Item.PlaceHolder.make, {
                          deviceType: deviceType
                        })
                  }),
              title: "장바구니",
              fallback: React.createElement(Cart_Buyer_Item.PlaceHolder.make, {
                    deviceType: deviceType
                  })
            });
}

function getServerSideProps(ctx) {
  var deviceType = DeviceDetect.detectDeviceFromCtx2(ctx.req);
  return Promise.resolve({
              props: {
                deviceType: deviceType
              }
            });
}

var Form;

var Util;

export {
  Query ,
  Mutation ,
  Form ,
  Util ,
  Container ,
  $$default ,
  $$default as default,
  getServerSideProps ,
}
/* react Not a pure module */
