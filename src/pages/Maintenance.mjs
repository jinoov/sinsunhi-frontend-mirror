// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Env from "../constants/Env.mjs";
import Swr from "swr";
import * as Fetch from "bs-fetch/src/Fetch.mjs";
import * as Spice from "@greenlabs/ppx-spice/src/rescript/Spice.mjs";
import * as React from "react";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Js_array from "rescript/lib/es6/js_array.js";
import Head from "next/head";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Js_promise from "rescript/lib/es6/js_promise.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "rescript/lib/es6/belt_Result.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as FetchHelper from "../utils/FetchHelper.mjs";
import * as Router from "next/router";
import * as Belt_SortArray from "rescript/lib/es6/belt_SortArray.js";
import Format from "date-fns/format";
import IsAfter from "date-fns/isAfter";
import IsBefore from "date-fns/isBefore";
import CompareDesc from "date-fns/compareDesc";
import * as ReactDialog from "@radix-ui/react-dialog";

function make(from, to_) {
  var now = new Date(Date.now());
  var isBetween = function (from, now, to$p) {
    if (IsAfter(now, from)) {
      return IsBefore(now, to$p);
    } else {
      return false;
    }
  };
  var match = new Date(from);
  var match$1 = Belt_Option.map(to_, (function (prim) {
          return new Date(prim);
        }));
  if (match$1 === undefined) {
    if (IsAfter(now, match)) {
      return {
              from: match,
              to_: undefined
            };
    } else {
      return ;
    }
  }
  var to_$p = Caml_option.valFromOption(match$1);
  if (isBetween(match, now, to_$p)) {
    return {
            from: match,
            to_: Caml_option.some(to_$p)
          };
  }
  
}

function format(param) {
  var formatForDisplay = function (date) {
    return Format(date, "MM월 dd일 HH시");
  };
  return "" + Format(param.from, "MM월 dd일 HH시") + " ~ " + Belt_Option.mapWithDefault(param.to_, "", formatForDisplay) + "";
}

var MaintenanceTime = {
  make: make,
  format: format
};

function t_encode(v) {
  return Js_dict.fromArray([[
                "name",
                Spice.stringToJson(v.name)
              ]]);
}

function t_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var name = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict._0, "name"), null));
  if (name.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: {
              name: name._0
            }
          };
  }
  var e = name._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".name" + e.path,
            message: e.message,
            value: e.value
          }
        };
}

var Component = {
  t_encode: t_encode,
  t_decode: t_decode
};

function t_encode$1(v) {
  return Js_dict.fromArray([
              [
                "affected_components",
                Spice.optionToJson((function (param) {
                        return Spice.arrayToJson(t_encode, param);
                      }), v.components)
              ],
              [
                "body",
                Spice.stringToJson(v.body)
              ],
              [
                "created_at",
                Spice.stringToJson(v.createdAt)
              ]
            ]);
}

function t_decode$1(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var components = Spice.optionFromJson((function (param) {
          return Spice.arrayFromJson(t_decode, param);
        }), Belt_Option.getWithDefault(Js_dict.get(dict$1, "affected_components"), null));
  if (components.TAG === /* Ok */0) {
    var body = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "body"), null));
    if (body.TAG === /* Ok */0) {
      var createdAt = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "created_at"), null));
      if (createdAt.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: {
                  components: components._0,
                  body: body._0,
                  createdAt: createdAt._0
                }
              };
      }
      var e = createdAt._0;
      return {
              TAG: /* Error */1,
              _0: {
                path: "." + ("created_at" + e.path),
                message: e.message,
                value: e.value
              }
            };
    }
    var e$1 = body._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".body" + e$1.path,
              message: e$1.message,
              value: e$1.value
            }
          };
  }
  var e$2 = components._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: "." + ("affected_components" + e$2.path),
            message: e$2.message,
            value: e$2.value
          }
        };
}

var IncidentUpdate = {
  t_encode: t_encode$1,
  t_decode: t_decode$1
};

function incident_encode(v) {
  return Js_dict.fromArray([
              [
                "components",
                Spice.arrayToJson(t_encode, v.components)
              ],
              [
                "id",
                Spice.stringToJson(v.id)
              ],
              [
                "impact",
                Spice.stringToJson(v.impact)
              ],
              [
                "name",
                Spice.optionToJson(Spice.stringToJson, v.name)
              ],
              [
                "created_at",
                Spice.stringToJson(v.createdAt)
              ],
              [
                "scheduled_for",
                Spice.optionToJson(Spice.stringToJson, v.scheduledFor)
              ],
              [
                "scheduled_until",
                Spice.optionToJson(Spice.stringToJson, v.scheduledUntil)
              ],
              [
                "started_at",
                Spice.optionToJson(Spice.stringToJson, v.startedAt)
              ],
              [
                "incident_updates",
                Spice.arrayToJson(t_encode$1, v.incidentUpdates)
              ]
            ]);
}

function incident_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var components = Spice.arrayFromJson(t_decode, Belt_Option.getWithDefault(Js_dict.get(dict$1, "components"), null));
  if (components.TAG === /* Ok */0) {
    var id = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "id"), null));
    if (id.TAG === /* Ok */0) {
      var impact = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "impact"), null));
      if (impact.TAG === /* Ok */0) {
        var name = Spice.optionFromJson(Spice.stringFromJson, Belt_Option.getWithDefault(Js_dict.get(dict$1, "name"), null));
        if (name.TAG === /* Ok */0) {
          var createdAt = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "created_at"), null));
          if (createdAt.TAG === /* Ok */0) {
            var scheduledFor = Spice.optionFromJson(Spice.stringFromJson, Belt_Option.getWithDefault(Js_dict.get(dict$1, "scheduled_for"), null));
            if (scheduledFor.TAG === /* Ok */0) {
              var scheduledUntil = Spice.optionFromJson(Spice.stringFromJson, Belt_Option.getWithDefault(Js_dict.get(dict$1, "scheduled_until"), null));
              if (scheduledUntil.TAG === /* Ok */0) {
                var startedAt = Spice.optionFromJson(Spice.stringFromJson, Belt_Option.getWithDefault(Js_dict.get(dict$1, "started_at"), null));
                if (startedAt.TAG === /* Ok */0) {
                  var incidentUpdates = Spice.arrayFromJson(t_decode$1, Belt_Option.getWithDefault(Js_dict.get(dict$1, "incident_updates"), null));
                  if (incidentUpdates.TAG === /* Ok */0) {
                    return {
                            TAG: /* Ok */0,
                            _0: {
                              components: components._0,
                              id: id._0,
                              impact: impact._0,
                              name: name._0,
                              createdAt: createdAt._0,
                              scheduledFor: scheduledFor._0,
                              scheduledUntil: scheduledUntil._0,
                              startedAt: startedAt._0,
                              incidentUpdates: incidentUpdates._0
                            }
                          };
                  }
                  var e = incidentUpdates._0;
                  return {
                          TAG: /* Error */1,
                          _0: {
                            path: "." + ("incident_updates" + e.path),
                            message: e.message,
                            value: e.value
                          }
                        };
                }
                var e$1 = startedAt._0;
                return {
                        TAG: /* Error */1,
                        _0: {
                          path: "." + ("started_at" + e$1.path),
                          message: e$1.message,
                          value: e$1.value
                        }
                      };
              }
              var e$2 = scheduledUntil._0;
              return {
                      TAG: /* Error */1,
                      _0: {
                        path: "." + ("scheduled_until" + e$2.path),
                        message: e$2.message,
                        value: e$2.value
                      }
                    };
            }
            var e$3 = scheduledFor._0;
            return {
                    TAG: /* Error */1,
                    _0: {
                      path: "." + ("scheduled_for" + e$3.path),
                      message: e$3.message,
                      value: e$3.value
                    }
                  };
          }
          var e$4 = createdAt._0;
          return {
                  TAG: /* Error */1,
                  _0: {
                    path: "." + ("created_at" + e$4.path),
                    message: e$4.message,
                    value: e$4.value
                  }
                };
        }
        var e$5 = name._0;
        return {
                TAG: /* Error */1,
                _0: {
                  path: ".name" + e$5.path,
                  message: e$5.message,
                  value: e$5.value
                }
              };
      }
      var e$6 = impact._0;
      return {
              TAG: /* Error */1,
              _0: {
                path: ".impact" + e$6.path,
                message: e$6.message,
                value: e$6.value
              }
            };
    }
    var e$7 = id._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".id" + e$7.path,
              message: e$7.message,
              value: e$7.value
            }
          };
  }
  var e$8 = components._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".components" + e$8.path,
            message: e$8.message,
            value: e$8.value
          }
        };
}

var Incident = {
  incident_encode: incident_encode,
  incident_decode: incident_decode
};

function incidents_encode(v) {
  return Spice.arrayToJson(incident_encode, v);
}

function incidents_decode(v) {
  return Spice.arrayFromJson(incident_decode, v);
}

function useStatusPage(apiEndpoint) {
  var fetcher = function (url) {
    return Js_promise.$$catch((function (param) {
                  return Promise.resolve(null);
                }), Js_promise.then_((function (data) {
                      return Promise.resolve(data);
                    }), Js_promise.then_((function (res) {
                          if (res.ok) {
                            return Fetch.$$Response.json(res);
                          } else {
                            return Js_promise.$$catch((function (err) {
                                          return Promise.reject(err);
                                        }), Js_promise.then_((function (errJson) {
                                              var error = new Error("요청에 실패했습니다.");
                                              error.status = res.status;
                                              error.info = errJson;
                                              var errJson$p = FetchHelper.errJson_decode(errJson);
                                              if (errJson$p.TAG === /* Ok */0) {
                                                error.message = errJson$p._0.message;
                                              }
                                              return Promise.reject(error);
                                            }), Fetch.$$Response.json(res)));
                          }
                        }), fetch(url, Fetch.RequestInit.make(/* Get */0, {
                                  Authorization: "OAuth " + Env.statusPageKey + ""
                                }, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)))));
  };
  var match = Swr("https://api.statuspage.io/v1/pages/" + Env.statusPagePageId + "/incidents/" + apiEndpoint + "", fetcher, {
        revalidateIfStale: false,
        revalidateOnFocus: false,
        revalidateOnReconnect: false,
        shouldRetryOnError: false,
        errorRetryCount: 0
      });
  var data = match.data;
  if (data !== undefined && match.error === undefined) {
    return Belt_Result.mapWithDefault(Spice.arrayFromJson(incident_decode, Caml_option.valFromOption(data)), undefined, (function (incident) {
                  return incident;
                }));
  }
  
}

var StatusPageAPI = {
  Component: Component,
  IncidentUpdate: IncidentUpdate,
  Incident: Incident,
  incidents_encode: incidents_encode,
  incidents_decode: incidents_decode,
  useStatusPage: useStatusPage
};

function make$1(currentSubPage, incidentTargets, message, from, to_) {
  var pathCheck = function (currentSubPage, incidentTargets) {
    return Belt_Option.isSome(Belt_Array.getBy(incidentTargets, (function (incidentTarget) {
                      return Caml_obj.equal(currentSubPage, incidentTarget);
                    })));
  };
  var match = pathCheck(currentSubPage, incidentTargets);
  var match$1 = make(from, to_);
  if (match && match$1 !== undefined) {
    return [{
              message: message,
              maintenanceTime: match$1
            }];
  }
  
}

function fromIncident(incident, currentSubPage) {
  var message = Belt_Option.map(Belt_Array.get(Belt_SortArray.stableSortBy(incident.incidentUpdates, (function (incidentA, incidentB) {
                  return CompareDesc(new Date(incidentA.createdAt), new Date(incidentB.createdAt));
                })), 0), (function (latestIncident) {
          return latestIncident.body;
        }));
  var incidentTarget = Belt_Array.map(incident.components, (function (component) {
          return component.name;
        }));
  var match = incident.scheduledFor;
  var match$1 = incident.scheduledUntil;
  if (match !== undefined && match$1 !== undefined) {
    return make$1(currentSubPage, incidentTarget, message, match, incident.scheduledUntil);
  }
  return make$1(currentSubPage, incidentTarget, message, incident.createdAt, undefined);
}

var Match = {
  make: make$1,
  fromIncident: fromIncident
};

function Maintenance$View(Props) {
  var message = Props.message;
  var maintenanceTime = Props.maintenanceTime;
  return React.createElement("section", {
              className: "w-screen h-screen flex flex-col items-center justify-start dialog-overlay bg-white pointer-events-none"
            }, React.createElement("div", {
                  className: "flex flex-col h-full items-center justify-center"
                }, React.createElement("img", {
                      height: "156",
                      src: "/images/maintenance.png",
                      width: "140"
                    }), React.createElement("h1", {
                      className: "mt-7 text-3xl text-gray-800 whitespace-pre text-center"
                    }, "더 나은 서비스를 위해서\n시스템 점검 중입니다"), React.createElement("div", {
                      className: "flex flex-col justify-center items-center gap-5"
                    }, React.createElement("h3", {
                          className: "mt-7 text-[17px] whitespace-pre text-center"
                        }, Belt_Option.getWithDefault(message, "점검 시간 동안 서비스 이용이 일시 중단됩니다.\n이용에 불편을 드려서 죄송합니다.")), React.createElement("div", {
                          className: "flex flex-col items-center py-3 bg-gray-gl rounded-lg w-[320px]"
                        }, React.createElement("span", {
                              className: ""
                            }, "점검 시간"), React.createElement("span", {
                              className: "text-gray-800 font-bold"
                            }, Belt_Option.getWithDefault(Belt_Option.map(maintenanceTime, format), "불러오는 중입니다"))))));
}

var View = {
  make: Maintenance$View
};

function Maintenance$Container(Props) {
  var router = Router.useRouter();
  var routerPathNames = router.pathname.split("/");
  var match = Belt_Array.get(routerPathNames, 1);
  var match$1 = Belt_Array.get(routerPathNames, 2);
  var currentSubPage;
  if (match !== undefined) {
    switch (match) {
      case "admin" :
          currentSubPage = "ADMIN";
          break;
      case "buyer" :
          currentSubPage = match$1 !== undefined ? "BUYER" : "COMMON";
          break;
      case "seller" :
          currentSubPage = "SELLER";
          break;
      default:
        currentSubPage = "COMMON";
    }
  } else {
    currentSubPage = "COMMON";
  }
  var incidents = useStatusPage("unresolved");
  var maintenance = useStatusPage("scheduled");
  var currentIncident = Belt_Array.get(Belt_Array.keepMap(incidents !== undefined ? (
              maintenance !== undefined ? Js_array.concat(incidents, maintenance) : incidents
            ) : (
              maintenance !== undefined ? maintenance : []
            ), (function (incidentList) {
              return fromIncident(incidentList, currentSubPage);
            })), 0);
  var message;
  var maintenanceTime;
  if (currentIncident === undefined) {
    return null;
  }
  var len = currentIncident.length;
  if (len >= 3) {
    return null;
  }
  switch (len) {
    case 0 :
        return null;
    case 1 :
        var match$2 = currentIncident[0];
        message = match$2.message;
        maintenanceTime = match$2.maintenanceTime;
        break;
    case 2 :
        var match$3 = currentIncident[0];
        message = match$3.message;
        maintenanceTime = match$3.maintenanceTime;
        break;
    
  }
  return React.createElement(ReactDialog.Root, {
              children: React.createElement(ReactDialog.Portal, {
                    children: null
                  }, React.createElement(ReactDialog.Overlay, {
                        className: "dialog-overlay"
                      }), React.createElement(ReactDialog.Content, {
                        children: null,
                        className: "top-0 bg-white fixed z-20"
                      }, React.createElement(Head, {
                            children: React.createElement("title", undefined, "🚧 신선하이 점검중입니다 🚧")
                          }), React.createElement(Maintenance$View, {
                            message: message,
                            maintenanceTime: maintenanceTime
                          }))),
              open: true
            });
}

var Container = {
  make: Maintenance$Container
};

function Maintenance(Props) {
  var match = React.useState(function () {
        return false;
      });
  var setIsCsr = match[1];
  React.useEffect((function () {
          setIsCsr(function (param) {
                return true;
              });
        }), []);
  if (match[0]) {
    return React.createElement(Maintenance$Container, {});
  } else {
    return null;
  }
}

var make$2 = Maintenance;

export {
  MaintenanceTime ,
  StatusPageAPI ,
  Match ,
  View ,
  Container ,
  make$2 as make,
}
/* Env Not a pure module */
