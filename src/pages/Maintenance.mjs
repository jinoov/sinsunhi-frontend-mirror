// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Env from "../constants/Env.mjs";
import Swr from "swr";
import * as Fetch from "bs-fetch/src/Fetch.mjs";
import * as Spice from "@greenlabs/ppx-spice/src/rescript/Spice.mjs";
import * as React from "react";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import Head from "next/head";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "rescript/lib/es6/belt_Result.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as FetchHelper from "../utils/FetchHelper.mjs";
import * as Router from "next/router";
import * as Belt_SortArray from "rescript/lib/es6/belt_SortArray.js";
import Format from "date-fns/format";
import IsAfter from "date-fns/isAfter";
import IsBefore from "date-fns/isBefore";
import CompareDesc from "date-fns/compareDesc";
import * as ReactDialog from "@radix-ui/react-dialog";

function afterCheck(from_) {
  return IsAfter(new Date(Date.now()), from_);
}

function beforeCheck(to_) {
  return IsBefore(new Date(Date.now()), to_);
}

function make(from, to_) {
  return Belt_Option.flatMap(Belt_Option.map(from, (function (prim) {
                    return new Date(prim);
                  })), (function (from) {
                if (!afterCheck(from)) {
                  return ;
                }
                var to_$1 = Belt_Option.map(to_, (function (prim) {
                        return new Date(prim);
                      }));
                if (to_$1 === undefined) {
                  return {
                          from: from,
                          to_: undefined
                        };
                }
                var to_$2 = Caml_option.valFromOption(to_$1);
                if (beforeCheck(to_$2)) {
                  return {
                          from: from,
                          to_: Caml_option.some(to_$2)
                        };
                }
                
              }));
}

function format(param) {
  var formatForDisplay = function (date) {
    return Format(date, "MM") + "월 " + Format(date, "dd") + "일 " + Format(date, "HH") + "시";
  };
  return formatForDisplay(param.from) + " ~ " + Belt_Option.getWithDefault(Belt_Option.map(param.to_, formatForDisplay), "");
}

var MaintenanceTime = {
  afterCheck: afterCheck,
  beforeCheck: beforeCheck,
  make: make,
  format: format
};

function make$1(pathname, target, message, from, to_) {
  var match = target.includes(pathname);
  var match$1 = make(from, to_);
  if (match && match$1 !== undefined) {
    return /* Matched */{
            _0: [{
                message: message,
                maintenanceTime: match$1
              }]
          };
  } else {
    return /* NotMatched */0;
  }
}

function join(a, b) {
  if (!a) {
    if (b) {
      return /* Matched */{
              _0: b._0
            };
    } else {
      return /* NotMatched */0;
    }
  }
  var a$1 = a._0;
  if (b) {
    return /* Matched */{
            _0: Belt_Array.concat(a$1, b._0)
          };
  } else {
    return /* Matched */{
            _0: a$1
          };
  }
}

function getIncidentForDisplay(t) {
  if (t) {
    return Belt_Array.get(t._0, 0);
  }
  
}

var Match = {
  make: make$1,
  join: join,
  getIncidentForDisplay: getIncidentForDisplay
};

function t_encode(v) {
  return Js_dict.fromArray([[
                "name",
                Spice.stringToJson(v.name)
              ]]);
}

function t_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var name = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict._0, "name"), null));
  if (name.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: {
              name: name._0
            }
          };
  }
  var e = name._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".name" + e.path,
            message: e.message,
            value: e.value
          }
        };
}

var Component = {
  t_encode: t_encode,
  t_decode: t_decode
};

function t_encode$1(v) {
  return Js_dict.fromArray([
              [
                "affected_components",
                Spice.optionToJson((function (param) {
                        return Spice.arrayToJson(t_encode, param);
                      }), v.components)
              ],
              [
                "body",
                Spice.stringToJson(v.body)
              ],
              [
                "created_at",
                Spice.stringToJson(v.createdAt)
              ]
            ]);
}

function t_decode$1(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var components = Spice.optionFromJson((function (param) {
          return Spice.arrayFromJson(t_decode, param);
        }), Belt_Option.getWithDefault(Js_dict.get(dict$1, "affected_components"), null));
  if (components.TAG === /* Ok */0) {
    var body = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "body"), null));
    if (body.TAG === /* Ok */0) {
      var createdAt = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "created_at"), null));
      if (createdAt.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: {
                  components: components._0,
                  body: body._0,
                  createdAt: createdAt._0
                }
              };
      }
      var e = createdAt._0;
      return {
              TAG: /* Error */1,
              _0: {
                path: ".created_at" + e.path,
                message: e.message,
                value: e.value
              }
            };
    }
    var e$1 = body._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".body" + e$1.path,
              message: e$1.message,
              value: e$1.value
            }
          };
  }
  var e$2 = components._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".affected_components" + e$2.path,
            message: e$2.message,
            value: e$2.value
          }
        };
}

var IncidentUpdate = {
  t_encode: t_encode$1,
  t_decode: t_decode$1
};

function incident_encode(v) {
  return Js_dict.fromArray([
              [
                "components",
                Spice.arrayToJson(t_encode, v.components)
              ],
              [
                "id",
                Spice.stringToJson(v.id)
              ],
              [
                "impact",
                Spice.stringToJson(v.impact)
              ],
              [
                "name",
                Spice.optionToJson(Spice.stringToJson, v.name)
              ],
              [
                "created_at",
                Spice.stringToJson(v.createdAt)
              ],
              [
                "scheduled_for",
                Spice.optionToJson(Spice.stringToJson, v.scheduledFor)
              ],
              [
                "scheduled_until",
                Spice.optionToJson(Spice.stringToJson, v.scheduledUntil)
              ],
              [
                "started_at",
                Spice.optionToJson(Spice.stringToJson, v.startedAt)
              ],
              [
                "incident_updates",
                Spice.arrayToJson(t_encode$1, v.incidentUpdates)
              ]
            ]);
}

function incident_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var components = Spice.arrayFromJson(t_decode, Belt_Option.getWithDefault(Js_dict.get(dict$1, "components"), null));
  if (components.TAG === /* Ok */0) {
    var id = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "id"), null));
    if (id.TAG === /* Ok */0) {
      var impact = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "impact"), null));
      if (impact.TAG === /* Ok */0) {
        var name = Spice.optionFromJson(Spice.stringFromJson, Belt_Option.getWithDefault(Js_dict.get(dict$1, "name"), null));
        if (name.TAG === /* Ok */0) {
          var createdAt = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "created_at"), null));
          if (createdAt.TAG === /* Ok */0) {
            var scheduledFor = Spice.optionFromJson(Spice.stringFromJson, Belt_Option.getWithDefault(Js_dict.get(dict$1, "scheduled_for"), null));
            if (scheduledFor.TAG === /* Ok */0) {
              var scheduledUntil = Spice.optionFromJson(Spice.stringFromJson, Belt_Option.getWithDefault(Js_dict.get(dict$1, "scheduled_until"), null));
              if (scheduledUntil.TAG === /* Ok */0) {
                var startedAt = Spice.optionFromJson(Spice.stringFromJson, Belt_Option.getWithDefault(Js_dict.get(dict$1, "started_at"), null));
                if (startedAt.TAG === /* Ok */0) {
                  var incidentUpdates = Spice.arrayFromJson(t_decode$1, Belt_Option.getWithDefault(Js_dict.get(dict$1, "incident_updates"), null));
                  if (incidentUpdates.TAG === /* Ok */0) {
                    return {
                            TAG: /* Ok */0,
                            _0: {
                              components: components._0,
                              id: id._0,
                              impact: impact._0,
                              name: name._0,
                              createdAt: createdAt._0,
                              scheduledFor: scheduledFor._0,
                              scheduledUntil: scheduledUntil._0,
                              startedAt: startedAt._0,
                              incidentUpdates: incidentUpdates._0
                            }
                          };
                  }
                  var e = incidentUpdates._0;
                  return {
                          TAG: /* Error */1,
                          _0: {
                            path: ".incident_updates" + e.path,
                            message: e.message,
                            value: e.value
                          }
                        };
                }
                var e$1 = startedAt._0;
                return {
                        TAG: /* Error */1,
                        _0: {
                          path: ".started_at" + e$1.path,
                          message: e$1.message,
                          value: e$1.value
                        }
                      };
              }
              var e$2 = scheduledUntil._0;
              return {
                      TAG: /* Error */1,
                      _0: {
                        path: ".scheduled_until" + e$2.path,
                        message: e$2.message,
                        value: e$2.value
                      }
                    };
            }
            var e$3 = scheduledFor._0;
            return {
                    TAG: /* Error */1,
                    _0: {
                      path: ".scheduled_for" + e$3.path,
                      message: e$3.message,
                      value: e$3.value
                    }
                  };
          }
          var e$4 = createdAt._0;
          return {
                  TAG: /* Error */1,
                  _0: {
                    path: ".created_at" + e$4.path,
                    message: e$4.message,
                    value: e$4.value
                  }
                };
        }
        var e$5 = name._0;
        return {
                TAG: /* Error */1,
                _0: {
                  path: ".name" + e$5.path,
                  message: e$5.message,
                  value: e$5.value
                }
              };
      }
      var e$6 = impact._0;
      return {
              TAG: /* Error */1,
              _0: {
                path: ".impact" + e$6.path,
                message: e$6.message,
                value: e$6.value
              }
            };
    }
    var e$7 = id._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".id" + e$7.path,
              message: e$7.message,
              value: e$7.value
            }
          };
  }
  var e$8 = components._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".components" + e$8.path,
            message: e$8.message,
            value: e$8.value
          }
        };
}

var Incident = {
  incident_encode: incident_encode,
  incident_decode: incident_decode
};

function apiEndPoint(t) {
  if (t) {
    return "scheduled";
  } else {
    return "unresolved";
  }
}

var Target = {
  apiEndPoint: apiEndPoint
};

function incidents_encode(v) {
  return Spice.arrayToJson(incident_encode, v);
}

function incidents_decode(v) {
  return Spice.arrayFromJson(incident_decode, v);
}

function use(target) {
  var apiFetcher = function (url) {
    return fetch(url, Fetch.RequestInit.make(/* Get */0, {
                            Authorization: "OAuth " + Env.statusPageKey
                          }, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)).then(function (res) {
                    if (res.ok) {
                      return res.json();
                    } else {
                      return res.json().then(function (errJson) {
                                    var error = new Error("요청에 실패했습니다.");
                                    error.status = res.status;
                                    error.info = errJson;
                                    var errJson$p = FetchHelper.errJson_decode(errJson);
                                    if (errJson$p.TAG === /* Ok */0) {
                                      error.message = errJson$p._0.message;
                                    }
                                    return Promise.reject(error);
                                  }).catch(function (err) {
                                  return Promise.reject(err);
                                });
                    }
                  }).then(function (data) {
                  return Promise.resolve(data);
                }).catch(function (param) {
                return Promise.resolve(null);
              });
  };
  var match = Swr("https://api.statuspage.io/v1/pages/" + Env.statusPagePageId + "/incidents/" + (
        target ? "scheduled" : "unresolved"
      ), apiFetcher, {
        revalidateIfStale: false,
        revalidateOnFocus: false,
        revalidateOnReconnect: false,
        shouldRetryOnError: false,
        errorRetryCount: 0
      });
  var data = match.data;
  if (data !== undefined && match.error === undefined) {
    return Belt_Result.mapWithDefault(Spice.arrayFromJson(incident_decode, Caml_option.valFromOption(data)), undefined, (function (incident) {
                  return incident;
                }));
  }
  
}

function isMaintenanceTarget(statusPageIncidents, pathname) {
  return Belt_Option.getWithDefault(Belt_Option.map(Belt_Option.map(statusPageIncidents, (function (statusPageIncidents) {
                        return Belt_Array.map(statusPageIncidents, (function (statusPageResult) {
                                      var message = Belt_Option.map(Belt_Array.get(Belt_SortArray.stableSortBy(statusPageResult.incidentUpdates, (function (incidentA, incidentB) {
                                                      return CompareDesc(new Date(incidentA.createdAt), new Date(incidentB.createdAt));
                                                    })), 0), (function (latestIncident) {
                                              return latestIncident.body;
                                            }));
                                      if (Belt_Option.isSome(statusPageResult.scheduledFor)) {
                                        return make$1(pathname, Belt_Array.map(Belt_Array.map(statusPageResult.components, (function (component) {
                                                              return component.name;
                                                            })), (function (name) {
                                                          return name.toLowerCase();
                                                        })), message, statusPageResult.scheduledFor, statusPageResult.scheduledUntil);
                                      } else {
                                        return make$1(pathname, Belt_Array.map(Belt_Array.map(statusPageResult.components, (function (component) {
                                                              return component.name;
                                                            })), (function (name) {
                                                          return name.toLowerCase();
                                                        })), message, statusPageResult.createdAt, undefined);
                                      }
                                    }));
                      })), (function (matches) {
                    return Belt_Array.reduce(matches, /* NotMatched */0, join);
                  })), /* NotMatched */0);
}

var StatusPageCompat = {
  Component: Component,
  IncidentUpdate: IncidentUpdate,
  Incident: Incident,
  Target: Target,
  incidents_encode: incidents_encode,
  incidents_decode: incidents_decode,
  use: use,
  isMaintenanceTarget: isMaintenanceTarget
};

function Maintenance$View(Props) {
  var message = Props.message;
  var maintenanceTime = Props.maintenanceTime;
  return React.createElement("section", {
              className: "w-screen h-screen flex flex-col items-center justify-start dialog-overlay"
            }, React.createElement("div", {
                  className: "flex flex-col h-full items-center justify-center"
                }, React.createElement("img", {
                      height: "156",
                      src: "/images/maintenance.png",
                      width: "140"
                    }), React.createElement("h1", {
                      className: "mt-7 text-3xl text-gray-800 whitespace-pre text-center"
                    }, "더 나은 서비스를 위해서\n시스템 점검 중입니다"), React.createElement("div", {
                      className: "flex flex-col justify-center items-center gap-5"
                    }, React.createElement("h3", {
                          className: "mt-7 text-[17px] whitespace-pre text-center"
                        }, Belt_Option.getWithDefault(message, "점검 시간 동안 서비스 이용이 일시 중단됩니다.\n이용에 불편을 드려서 죄송합니다.")), React.createElement("div", {
                          className: "flex flex-col items-center py-3 bg-gray-gl rounded-lg w-[320px]"
                        }, React.createElement("span", {
                              className: ""
                            }, "점검 시간"), React.createElement("span", {
                              className: "text-gray-800 font-bold"
                            }, Belt_Option.getWithDefault(Belt_Option.map(maintenanceTime, format), "불러오는 중입니다"))))));
}

var View = {
  make: Maintenance$View
};

function Maintenance$Content(Props) {
  var currentPathName = Belt_Option.getWithDefault(Belt_Array.get(Router.useRouter().pathname.split("/"), 1), "");
  var incidentResultFromStatusPage = isMaintenanceTarget(use(/* Incident */0), currentPathName);
  var maintenanceResultFromStatusPage = isMaintenanceTarget(use(/* Maintenance */1), currentPathName);
  var match = getIncidentForDisplay(join(incidentResultFromStatusPage, maintenanceResultFromStatusPage));
  if (match !== undefined) {
    return React.createElement(ReactDialog.Root, {
                children: React.createElement(ReactDialog.Portal, {
                      children: null
                    }, React.createElement(ReactDialog.Overlay, {
                          className: "dialog-overlay"
                        }), React.createElement(ReactDialog.Content, {
                          children: null,
                          className: "top-0 bg-white fixed z-20"
                        }, React.createElement(Head, {
                              children: React.createElement("title", undefined, "🚧 신선하이 점검중입니다 🚧")
                            }), React.createElement(Maintenance$View, {
                              message: match.message,
                              maintenanceTime: match.maintenanceTime
                            }))),
                open: true
              });
  } else {
    return null;
  }
}

var Content = {
  make: Maintenance$Content
};

function Maintenance(Props) {
  var match = React.useState(function () {
        return false;
      });
  var setIsCsr = match[1];
  React.useEffect((function () {
          setIsCsr(function (param) {
                return true;
              });
          
        }), []);
  if (match[0]) {
    return React.createElement(Maintenance$Content, {});
  } else {
    return null;
  }
}

var make$2 = Maintenance;

export {
  MaintenanceTime ,
  Match ,
  StatusPageCompat ,
  View ,
  Content ,
  make$2 as make,
  
}
/* Env Not a pure module */
