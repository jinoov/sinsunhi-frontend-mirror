// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Env from "../constants/Env.mjs";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Fetch from "bs-fetch/src/Fetch.mjs";
import * as Spice from "@greenlabs/ppx-spice/src/rescript/Spice.mjs";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Sentry from "../bindings/Sentry.mjs";
import * as GraphQL from "./GraphQL.mjs";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Redirect from "../components/Redirect.mjs";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Js_promise from "rescript/lib/es6/js_promise.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Garter_Array from "@greenlabs/garter/src/Garter_Array.mjs";
import * as Nextjs from "@sentry/nextjs";
import * as LocalStorageHooks from "./LocalStorageHooks.mjs";

function errJson_encode(v) {
  return Js_dict.fromArray([[
                "message",
                Spice.stringToJson(v.message)
              ]]);
}

function errJson_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var message = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict._0, "message"), null));
  if (message.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: {
              message: message._0
            }
          };
  }
  var e = message._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".message" + e.path,
            message: e.message,
            value: e.value
          }
        };
}

function get(url, onSuccess, onFailure) {
  return Js_promise.$$catch((function (err) {
                return Promise.resolve(Curry._1(onFailure, err));
              }), Js_promise.then_((function (json) {
                    return Promise.resolve(Curry._1(onSuccess, json));
                  }), Js_promise.then_((function (res) {
                        if (res.ok) {
                          return Fetch.$$Response.json(res);
                        } else {
                          return Js_promise.$$catch((function (err) {
                                        return Promise.reject(err);
                                      }), Js_promise.then_((function (errJson) {
                                            var error = new Error("요청에 실패했습니다.");
                                            error.status = res.status;
                                            error.info = errJson;
                                            var errJson$p = errJson_decode(errJson);
                                            if (errJson$p.TAG === /* Ok */0) {
                                              error.message = errJson$p._0.message;
                                            }
                                            return Promise.reject(error);
                                          }), Fetch.$$Response.json(res)));
                        }
                      }), fetch(url, Fetch.RequestInit.make(/* Get */0, {
                                "Content-Type": "application/json"
                              }, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)))));
}

function post(url, body, onSuccess, onFailure) {
  return Js_promise.$$catch((function (err) {
                return Promise.resolve(Curry._1(onFailure, err));
              }), Js_promise.then_((function (json) {
                    return Promise.resolve(Curry._1(onSuccess, json));
                  }), Js_promise.then_((function (res) {
                        if (res.ok) {
                          return Fetch.$$Response.json(res);
                        } else {
                          return Js_promise.$$catch((function (err) {
                                        return Promise.reject(err);
                                      }), Js_promise.then_((function (errJson) {
                                            var error = new Error("요청에 실패했습니다.");
                                            error.status = res.status;
                                            error.info = errJson;
                                            var errJson$p = errJson_decode(errJson);
                                            if (errJson$p.TAG === /* Ok */0) {
                                              error.message = errJson$p._0.message;
                                            }
                                            return Promise.reject(error);
                                          }), Fetch.$$Response.json(res)));
                        }
                      }), fetch(url, Fetch.RequestInit.make(/* Post */2, {
                                "Content-Type": "application/json"
                              }, Caml_option.some(body), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)))));
}

function postWithURLSearchParams(url, urlSearchParams, onSuccess, onFailure) {
  return Js_promise.$$catch((function (err) {
                return Promise.resolve(Curry._1(onFailure, err));
              }), Js_promise.then_((function (json) {
                    return Promise.resolve(Curry._1(onSuccess, json));
                  }), Js_promise.then_((function (res) {
                        if (res.ok) {
                          return Fetch.$$Response.json(res);
                        } else {
                          return Js_promise.$$catch((function (err) {
                                        return Promise.reject(err);
                                      }), Js_promise.then_((function (errJson) {
                                            var error = new Error("요청에 실패했습니다.");
                                            error.status = res.status;
                                            error.info = errJson;
                                            var errJson$p = errJson_decode(errJson);
                                            if (errJson$p.TAG === /* Ok */0) {
                                              error.message = errJson$p._0.message;
                                            }
                                            return Promise.reject(error);
                                          }), Fetch.$$Response.json(res)));
                        }
                      }), fetch(url, Fetch.RequestInit.make(/* Post */2, {
                                "Content-Type": "application/x-www-form-urlencoded"
                              }, Caml_option.some(urlSearchParams), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)))));
}

function put(url, body, onSuccess, onFailure) {
  return Js_promise.$$catch((function (err) {
                return Promise.resolve(Curry._1(onFailure, err));
              }), Js_promise.then_((function (json) {
                    return Promise.resolve(Curry._1(onSuccess, json));
                  }), Js_promise.then_((function (res) {
                        if (res.ok) {
                          return Fetch.$$Response.json(res);
                        } else {
                          return Js_promise.$$catch((function (err) {
                                        return Promise.reject(err);
                                      }), Js_promise.then_((function (errJson) {
                                            var error = new Error("요청에 실패했습니다.");
                                            error.status = res.status;
                                            error.info = errJson;
                                            var errJson$p = errJson_decode(errJson);
                                            if (errJson$p.TAG === /* Ok */0) {
                                              error.message = errJson$p._0.message;
                                            }
                                            return Promise.reject(error);
                                          }), Fetch.$$Response.json(res)));
                        }
                      }), fetch(url, Fetch.RequestInit.make(/* Put */3, {
                                "Content-Type": "application/json"
                              }, Caml_option.some(body), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)))));
}

function putWithToken(url, body) {
  var accessToken = Curry._1(LocalStorageHooks.AccessToken.get, undefined);
  return Js_promise.then_((function (res) {
                if (res.ok) {
                  return Fetch.$$Response.json(res);
                } else {
                  return Js_promise.$$catch((function (err) {
                                return Promise.reject(err);
                              }), Js_promise.then_((function (errJson) {
                                    var error = new Error("요청에 실패했습니다.");
                                    error.status = res.status;
                                    error.info = errJson;
                                    var errJson$p = errJson_decode(errJson);
                                    if (errJson$p.TAG === /* Ok */0) {
                                      error.message = errJson$p._0.message;
                                    }
                                    return Promise.reject(error);
                                  }), Fetch.$$Response.json(res)));
                }
              }), fetch(url, Fetch.RequestInit.make(/* Put */3, {
                        "Content-Type": "application/json",
                        Authorization: "Bearer " + accessToken + ""
                      }, Caml_option.some(body), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)));
}

function putWithFormData(url, formData, onSuccess, onFailure) {
  return Js_promise.$$catch((function (err) {
                return Promise.resolve(Curry._1(onFailure, err));
              }), Js_promise.then_((function (res) {
                    return Promise.resolve(Curry._1(onSuccess, res));
                  }), Js_promise.then_((function (res) {
                        if (res.ok) {
                          return Promise.resolve(res);
                        } else {
                          return Js_promise.$$catch((function (err) {
                                        return Promise.reject(err);
                                      }), Js_promise.then_((function (errJson) {
                                            var error = new Error("요청에 실패했습니다.");
                                            error.status = res.status;
                                            error.info = errJson;
                                            var errJson$p = errJson_decode(errJson);
                                            if (errJson$p.TAG === /* Ok */0) {
                                              error.message = errJson$p._0.message;
                                            }
                                            return Promise.reject(error);
                                          }), Fetch.$$Response.json(res)));
                        }
                      }), fetch(url, Fetch.RequestInit.make(/* Put */3, undefined, Caml_option.some(formData), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)))));
}

function putWithFile(url, file) {
  return Js_promise.then_((function (res) {
                if (res.ok) {
                  return Promise.resolve(res);
                } else {
                  return Js_promise.$$catch((function (err) {
                                return Promise.reject(err);
                              }), Js_promise.then_((function (errJson) {
                                    var error = new Error("요청에 실패했습니다.");
                                    error.status = res.status;
                                    error.info = errJson;
                                    var errJson$p = errJson_decode(errJson);
                                    if (errJson$p.TAG === /* Ok */0) {
                                      error.message = errJson$p._0.message;
                                    }
                                    return Promise.reject(error);
                                  }), Fetch.$$Response.json(res)));
                }
              }), fetch(url, Fetch.RequestInit.make(/* Put */3, undefined, Caml_option.some(file), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)));
}

function putWithFileAsAttachment(url, file) {
  return Js_promise.then_((function (res) {
                if (res.ok) {
                  return Promise.resolve(res);
                } else {
                  return Js_promise.$$catch((function (err) {
                                return Promise.reject(err);
                              }), Js_promise.then_((function (errJson) {
                                    var error = new Error("요청에 실패했습니다.");
                                    error.status = res.status;
                                    error.info = errJson;
                                    var errJson$p = errJson_decode(errJson);
                                    if (errJson$p.TAG === /* Ok */0) {
                                      error.message = errJson$p._0.message;
                                    }
                                    return Promise.reject(error);
                                  }), Fetch.$$Response.json(res)));
                }
              }), fetch(url, Fetch.RequestInit.make(/* Put */3, [[
                          "Content-Disposition",
                          "attachment"
                        ]], Caml_option.some(file), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)));
}

function fetcher(url) {
  var accessToken = Curry._1(LocalStorageHooks.AccessToken.get, undefined);
  return Js_promise.then_((function (res) {
                if (res.ok) {
                  return Fetch.$$Response.json(res);
                } else {
                  return Js_promise.$$catch((function (err) {
                                return Promise.reject(err);
                              }), Js_promise.then_((function (errJson) {
                                    var error = new Error("요청에 실패했습니다.");
                                    error.status = res.status;
                                    error.info = errJson;
                                    var errJson$p = errJson_decode(errJson);
                                    if (errJson$p.TAG === /* Ok */0) {
                                      error.message = errJson$p._0.message;
                                    }
                                    return Promise.reject(error);
                                  }), Fetch.$$Response.json(res)));
                }
              }), fetch(url, Fetch.RequestInit.make(/* Get */0, {
                        "Content-Type": "application/json",
                        Authorization: "Bearer " + accessToken + ""
                      }, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)));
}

function getWithToken(url, _body) {
  var accessToken = Curry._1(LocalStorageHooks.AccessToken.get, undefined);
  return Js_promise.then_((function (res) {
                if (res.ok) {
                  return Fetch.$$Response.json(res);
                } else {
                  return Js_promise.$$catch((function (err) {
                                return Promise.reject(err);
                              }), Js_promise.then_((function (errJson) {
                                    var error = new Error("요청에 실패했습니다.");
                                    error.status = res.status;
                                    error.info = errJson;
                                    var errJson$p = errJson_decode(errJson);
                                    if (errJson$p.TAG === /* Ok */0) {
                                      error.message = errJson$p._0.message;
                                    }
                                    return Promise.reject(error);
                                  }), Fetch.$$Response.json(res)));
                }
              }), fetch(url, Fetch.RequestInit.make(/* Get */0, {
                        "Content-Type": "application/json",
                        Authorization: "Bearer " + accessToken + ""
                      }, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)));
}

function getWithTokenForExcel(url, _body) {
  var accessToken = Curry._1(LocalStorageHooks.AccessToken.get, undefined);
  return Js_promise.then_((function (res) {
                if (res.ok) {
                  return Promise.resolve(res);
                } else {
                  return Js_promise.$$catch((function (err) {
                                return Promise.reject(err);
                              }), Js_promise.then_((function (errJson) {
                                    var error = new Error("요청에 실패했습니다.");
                                    error.status = res.status;
                                    error.info = errJson;
                                    var errJson$p = errJson_decode(errJson);
                                    if (errJson$p.TAG === /* Ok */0) {
                                      error.message = errJson$p._0.message;
                                    }
                                    return Promise.reject(error);
                                  }), Fetch.$$Response.json(res)));
                }
              }), fetch(url, Fetch.RequestInit.make(/* Get */0, {
                        "Content-Type": "application/json",
                        Authorization: "Bearer " + accessToken + ""
                      }, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)));
}

function getProcessedImage(url, _body) {
  return Js_promise.then_((function (res) {
                if (res.ok) {
                  return Promise.resolve(res);
                } else {
                  return Promise.reject(Js_exn.raiseError("처리된 이미지를 찾을 수 없습니다."));
                }
              }), fetch(url, Fetch.RequestInit.make(/* Get */0, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)));
}

function postWithToken(url, body) {
  var accessToken = Curry._1(LocalStorageHooks.AccessToken.get, undefined);
  var headers = accessToken === "" ? ({
        "Content-Type": "application/json",
        Accept: "application/json"
      }) : ({
        "Content-Type": "application/json",
        Accept: "application/json",
        Authorization: "Bearer " + accessToken + ""
      });
  return Js_promise.then_((function (res) {
                if (res.ok) {
                  if (res.status === 201 || res.status === 204) {
                    return Promise.resolve(null);
                  } else {
                    return Fetch.$$Response.json(res);
                  }
                } else {
                  return Js_promise.$$catch((function (err) {
                                return Promise.reject(err);
                              }), Js_promise.then_((function (errJson) {
                                    var error = new Error("요청에 실패했습니다.");
                                    error.status = res.status;
                                    error.info = errJson;
                                    var errJson$p = errJson_decode(errJson);
                                    if (errJson$p.TAG === /* Ok */0) {
                                      error.message = errJson$p._0.message;
                                    }
                                    return Promise.reject(error);
                                  }), Fetch.$$Response.json(res)));
                }
              }), fetch(url, Fetch.RequestInit.make(/* Post */2, Caml_option.some(headers), Caml_option.some(body), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)));
}

function postWithTokenForExcel(url, body) {
  var accessToken = Curry._1(LocalStorageHooks.AccessToken.get, undefined);
  return Js_promise.then_((function (res) {
                if (res.ok) {
                  return Promise.resolve(res);
                } else {
                  return Js_promise.$$catch((function (err) {
                                return Promise.reject(err);
                              }), Js_promise.then_((function (errJson) {
                                    var error = new Error("요청에 실패했습니다.");
                                    error.status = res.status;
                                    error.info = errJson;
                                    var errJson$p = errJson_decode(errJson);
                                    if (errJson$p.TAG === /* Ok */0) {
                                      error.message = errJson$p._0.message;
                                    }
                                    return Promise.reject(error);
                                  }), Fetch.$$Response.json(res)));
                }
              }), fetch(url, Fetch.RequestInit.make(/* Post */2, {
                        "Content-Type": "application/json",
                        Authorization: "Bearer " + accessToken + ""
                      }, Caml_option.some(body), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)));
}

function patchWithToken(url, body) {
  var accessToken = Curry._1(LocalStorageHooks.AccessToken.get, undefined);
  var headers = accessToken === "" ? ({
        "Content-Type": "application/json",
        Accept: "application/json"
      }) : ({
        "Content-Type": "application/json",
        Accept: "application/json",
        Authorization: "Bearer " + accessToken + ""
      });
  return Js_promise.then_((function (res) {
                if (res.ok) {
                  if (res.status === 201 || res.status === 204) {
                    return Promise.resolve(null);
                  } else {
                    return Fetch.$$Response.json(res);
                  }
                } else {
                  return Js_promise.$$catch((function (err) {
                                return Promise.reject(err);
                              }), Js_promise.then_((function (errJson) {
                                    var error = new Error("요청에 실패했습니다.");
                                    error.status = res.status;
                                    error.info = errJson;
                                    var errJson$p = errJson_decode(errJson);
                                    if (errJson$p.TAG === /* Ok */0) {
                                      error.message = errJson$p._0.message;
                                    }
                                    return Promise.reject(error);
                                  }), Fetch.$$Response.json(res)));
                }
              }), fetch(url, Fetch.RequestInit.make(/* Patch */8, Caml_option.some(headers), Caml_option.some(body), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)));
}

function responseToken_encode(v) {
  return Js_dict.fromArray([
              [
                "token",
                Spice.stringToJson(v.token)
              ],
              [
                "refresh-token",
                Spice.stringToJson(v.refreshToken)
              ]
            ]);
}

function responseToken_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var token = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "token"), null));
  if (token.TAG === /* Ok */0) {
    var refreshToken = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "refresh-token"), null));
    if (refreshToken.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: {
                token: token._0,
                refreshToken: refreshToken._0
              }
            };
    }
    var e = refreshToken._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: "." + ("refresh-token" + e.path),
              message: e.message,
              value: e.value
            }
          };
  }
  var e$1 = token._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".token" + e$1.path,
            message: e$1.message,
            value: e$1.value
          }
        };
}

function refreshToken(param) {
  var rt = Curry._1(LocalStorageHooks.RefreshToken.get, undefined);
  var urlSearchParams = new URLSearchParams([
          [
            "grant-type",
            "refresh-token"
          ],
          [
            "refresh-token",
            rt
          ]
        ]).toString();
  return Js_promise.$$catch((function (err) {
                if (err.status === 400) {
                  Curry._1(LocalStorageHooks.AccessToken.remove, undefined);
                  Curry._1(LocalStorageHooks.RefreshToken.remove, undefined);
                }
                return Promise.reject(Js_exn.raiseError("토큰 갱신에 실패하였습니다."));
              }), Js_promise.then_((function (res) {
                    var result = responseToken_decode(res);
                    if (result.TAG !== /* Ok */0) {
                      return Promise.reject(Js_exn.raiseError("토큰 갱신에 실패하였습니다."));
                    }
                    var res$1 = result._0;
                    Curry._1(LocalStorageHooks.AccessToken.set, res$1.token);
                    Curry._1(LocalStorageHooks.RefreshToken.set, res$1.refreshToken);
                    return Promise.resolve(undefined);
                  }), Js_promise.then_((function (res) {
                        if (res.ok) {
                          return Fetch.$$Response.json(res);
                        } else {
                          return Js_promise.$$catch((function (err) {
                                        return Promise.reject(err);
                                      }), Js_promise.then_((function (errJson) {
                                            var error = new Error("요청에 실패했습니다.");
                                            error.status = res.status;
                                            error.info = errJson;
                                            var errJson$p = errJson_decode(errJson);
                                            if (errJson$p.TAG === /* Ok */0) {
                                              error.message = errJson$p._0.message;
                                            }
                                            return Promise.reject(error);
                                          }), Fetch.$$Response.json(res)));
                        }
                      }), fetch("" + Env.restApiUrl + "/user/token", Fetch.RequestInit.make(/* Post */2, {
                                "Content-Type": "application/x-www-form-urlencoded"
                              }, Caml_option.some(urlSearchParams), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)))));
}

function wait(ms) {
  return new Promise((function (resolve, reject) {
                setTimeout((function (param) {
                        resolve(true);
                      }), ms);
              }));
}

function retry(errOpt, fn, count, interval) {
  var err = errOpt !== undefined ? Caml_option.valFromOption(errOpt) : undefined;
  if (count <= 0) {
    Belt_Option.forEach(err, (function (err) {
            Nextjs.captureException(err);
          }));
    return Promise.reject(Belt_Option.getWithDefault(err, Js_exn.raiseError("요청 재시도를 실패하였습니다.")));
  } else {
    return Js_promise.$$catch((function (err) {
                  if (err.status === 401) {
                    return Js_promise.$$catch((function (_err) {
                                  Redirect.redirectByRole(undefined);
                                  return Promise.reject(err);
                                }), Js_promise.then_((function (param) {
                                      return Js_promise.then_((function (param) {
                                                    return retry(Caml_option.some(undefined), fn, count - 1 | 0, interval);
                                                  }), wait(interval));
                                    }), refreshToken(undefined)));
                  } else {
                    return Js_promise.then_((function (param) {
                                  return retry(Caml_option.some(err), fn, count - 1 | 0, interval);
                                }), wait(interval));
                  }
                }), Curry._1(fn, undefined));
  }
}

function fetchWithRetry(fetcher, url, body, count) {
  return retry(Caml_option.some(undefined), (function (param) {
                return Curry._2(fetcher, url, body);
              }), count, 0);
}

function fetchWithIntervalRetry(fetcher, url, body, count, interval) {
  return retry(Caml_option.some(undefined), (function (param) {
                return Curry._2(fetcher, url, body);
              }), count, interval);
}

function relayResponse_encode(v) {
  return Js_dict.fromArray([
              [
                "data",
                Spice.optionToJson((function (v) {
                        return v;
                      }), v.data)
              ],
              [
                "errors",
                Spice.optionToJson((function (param) {
                        return Spice.arrayToJson(GraphQL.$$Error.t_encode, param);
                      }), v.errors)
              ]
            ]);
}

function relayResponse_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var data = Spice.optionFromJson((function (v) {
          return {
                  TAG: /* Ok */0,
                  _0: v
                };
        }), Belt_Option.getWithDefault(Js_dict.get(dict$1, "data"), null));
  if (data.TAG === /* Ok */0) {
    var errors = Spice.optionFromJson((function (param) {
            return Spice.arrayFromJson(GraphQL.$$Error.t_decode, param);
          }), Belt_Option.getWithDefault(Js_dict.get(dict$1, "errors"), null));
    if (errors.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: {
                data: data._0,
                errors: errors._0
              }
            };
    }
    var e = errors._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".errors" + e.path,
              message: e.message,
              value: e.value
            }
          };
  }
  var e$1 = data._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".data" + e$1.path,
            message: e$1.message,
            value: e$1.value
          }
        };
}

function relayResponseData_encode(v) {
  return Js_dict.fromArray([
              [
                "__typename",
                Spice.optionToJson((function (v) {
                        return v;
                      }), v.__typename)
              ],
              [
                "message",
                Spice.optionToJson((function (v) {
                        return v;
                      }), v.message)
              ]
            ]);
}

function relayResponseData_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var __typename = Spice.optionFromJson((function (v) {
          return {
                  TAG: /* Ok */0,
                  _0: v
                };
        }), Belt_Option.getWithDefault(Js_dict.get(dict$1, "__typename"), null));
  if (__typename.TAG === /* Ok */0) {
    var message = Spice.optionFromJson((function (v) {
            return {
                    TAG: /* Ok */0,
                    _0: v
                  };
          }), Belt_Option.getWithDefault(Js_dict.get(dict$1, "message"), null));
    if (message.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: {
                __typename: __typename._0,
                message: message._0
              }
            };
    }
    var e = message._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".message" + e.path,
              message: e.message,
              value: e.value
            }
          };
  }
  var e$1 = __typename._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".__typename" + e$1.path,
            message: e$1.message,
            value: e$1.value
          }
        };
}

function checkResponseErrorForSentry(relayResponse, body) {
  Belt_Option.forEach(relayResponse.data, (function (x) {
          var obj = Js_json.classify(x);
          if (typeof obj === "number") {
            return ;
          }
          if (obj.TAG !== /* JSONObject */2) {
            return ;
          }
          var obj$1 = obj._0;
          var resultObj = Belt_Option.flatMap(Garter_Array.first(Object.keys(obj$1)), (function (firstKey) {
                  return Js_dict.get(obj$1, firstKey);
                }));
          Belt_Option.forEach(resultObj, (function (obj) {
                  var relayResponse = relayResponseData_decode(obj);
                  if (relayResponse.TAG !== /* Ok */0) {
                    return ;
                  }
                  var relayResponse$1 = relayResponse._0;
                  Belt_Option.forEach(relayResponse$1.__typename, (function (__typename$p) {
                          if (Belt_Option.mapWithDefault(Js_json.decodeString(__typename$p), false, (function (s) {
                                    return s === "Error";
                                  }))) {
                            return Sentry.CaptureException.makeWithRelayError("RelayResponseResultError", relayResponse$1.message, body);
                          }
                          
                        }));
                }));
        }));
  Belt_Option.forEach(Belt_Option.map(relayResponse.errors, (function (errors) {
              return Belt_Array.keep(errors, (function (error) {
                            return error.message !== "Unauthorized";
                          }));
            })), (function (errors) {
          if (errors.length !== 0) {
            return Sentry.CaptureException.makeWithRelayError("RelayError", errors, body);
          }
          
        }));
}

function fetchWithRetryForRelay(fetcher, url, body, count) {
  var fn = function (param) {
    return Js_promise.then_((function (json) {
                  var relayResponse$p = relayResponse_decode(json);
                  if (relayResponse$p.TAG !== /* Ok */0) {
                    return Promise.reject(Js_exn.raiseError("Cannot parse Relay response"));
                  }
                  var relayResponse$p$1 = relayResponse$p._0;
                  if (Belt_Option.isSome(Belt_Option.flatMap(relayResponse$p$1.errors, (function (errors$p) {
                                return Belt_Array.getBy(errors$p, (function (error) {
                                              return error.message === "Unauthorized";
                                            }));
                              })))) {
                    var error = new Error("릴레이 Unauthorized");
                    error.status = 401;
                    return Promise.reject(error);
                  }
                  checkResponseErrorForSentry(relayResponse$p$1, body);
                  return Promise.resolve(json);
                }), Curry._2(fetcher, url, body));
  };
  return retry(Caml_option.some(undefined), fn, count, 0);
}

function requestWithRetry(fetcher, url, body, count, onSuccess, onFailure) {
  return Js_promise.$$catch((function (err) {
                return Promise.resolve(Curry._1(onFailure, err));
              }), Js_promise.then_((function (json) {
                    return Promise.resolve(Curry._1(onSuccess, json));
                  }), fetchWithRetry(fetcher, url, body, count)));
}

export {
  errJson_encode ,
  errJson_decode ,
  get ,
  post ,
  postWithURLSearchParams ,
  put ,
  putWithToken ,
  putWithFormData ,
  putWithFile ,
  putWithFileAsAttachment ,
  fetcher ,
  getWithToken ,
  getWithTokenForExcel ,
  getProcessedImage ,
  postWithToken ,
  postWithTokenForExcel ,
  patchWithToken ,
  responseToken_encode ,
  responseToken_decode ,
  refreshToken ,
  wait ,
  retry ,
  fetchWithRetry ,
  fetchWithIntervalRetry ,
  relayResponse_encode ,
  relayResponse_decode ,
  relayResponseData_encode ,
  relayResponseData_decode ,
  checkResponseErrorForSentry ,
  fetchWithRetryForRelay ,
  requestWithRetry ,
}
/* Env Not a pure module */
