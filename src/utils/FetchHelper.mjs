// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Env from "../constants/Env.mjs";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Fetch from "bs-fetch/src/Fetch.mjs";
import * as Spice from "@greenlabs/ppx-spice/src/rescript/Spice.mjs";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Sentry from "../bindings/Sentry.mjs";
import * as GraphQL from "./GraphQL.mjs";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Garter_Array from "@greenlabs/garter/src/Garter_Array.mjs";
import * as Nextjs from "@sentry/nextjs";
import * as LocalStorageHooks from "./LocalStorageHooks.mjs";

function errJson_encode(v) {
  return Js_dict.fromArray([[
                "message",
                Spice.stringToJson(v.message)
              ]]);
}

function errJson_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var message = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict._0, "message"), null));
  if (message.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: {
              message: message._0
            }
          };
  }
  var e = message._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".message" + e.path,
            message: e.message,
            value: e.value
          }
        };
}

function get(url, onSuccess, onFailure) {
  return fetch(url, Fetch.RequestInit.make(/* Get */0, {
                          "Content-Type": "application/json"
                        }, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)).then(function (res) {
                  if (res.ok) {
                    return res.json();
                  } else {
                    return res.json().then(function (errJson) {
                                  var error = new Error("요청에 실패했습니다.");
                                  error.status = res.status;
                                  error.info = errJson;
                                  var errJson$p = errJson_decode(errJson);
                                  if (errJson$p.TAG === /* Ok */0) {
                                    error.message = errJson$p._0.message;
                                  }
                                  return Promise.reject(error);
                                }).catch(function (err) {
                                return Promise.reject(err);
                              });
                  }
                }).then(function (json) {
                return Promise.resolve(Curry._1(onSuccess, json));
              }).catch(function (err) {
              return Promise.resolve(Curry._1(onFailure, err));
            });
}

function post(url, body, onSuccess, onFailure) {
  return fetch(url, Fetch.RequestInit.make(/* Post */2, {
                          "Content-Type": "application/json"
                        }, Caml_option.some(body), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)).then(function (res) {
                  if (res.ok) {
                    return res.json();
                  } else {
                    return res.json().then(function (errJson) {
                                  var error = new Error("요청에 실패했습니다.");
                                  error.status = res.status;
                                  error.info = errJson;
                                  var errJson$p = errJson_decode(errJson);
                                  if (errJson$p.TAG === /* Ok */0) {
                                    error.message = errJson$p._0.message;
                                  }
                                  return Promise.reject(error);
                                }).catch(function (err) {
                                return Promise.reject(err);
                              });
                  }
                }).then(function (json) {
                return Promise.resolve(Curry._1(onSuccess, json));
              }).catch(function (err) {
              return Promise.resolve(Curry._1(onFailure, err));
            });
}

function postWithURLSearchParams(url, urlSearchParams, onSuccess, onFailure) {
  return fetch(url, Fetch.RequestInit.make(/* Post */2, {
                          "Content-Type": "application/x-www-form-urlencoded"
                        }, Caml_option.some(urlSearchParams), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)).then(function (res) {
                  if (res.ok) {
                    return res.json();
                  } else {
                    return res.json().then(function (errJson) {
                                  var error = new Error("요청에 실패했습니다.");
                                  error.status = res.status;
                                  error.info = errJson;
                                  var errJson$p = errJson_decode(errJson);
                                  if (errJson$p.TAG === /* Ok */0) {
                                    error.message = errJson$p._0.message;
                                  }
                                  return Promise.reject(error);
                                }).catch(function (err) {
                                return Promise.reject(err);
                              });
                  }
                }).then(function (json) {
                return Promise.resolve(Curry._1(onSuccess, json));
              }).catch(function (err) {
              return Promise.resolve(Curry._1(onFailure, err));
            });
}

function put(url, body, onSuccess, onFailure) {
  return fetch(url, Fetch.RequestInit.make(/* Put */3, {
                          "Content-Type": "application/json"
                        }, Caml_option.some(body), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)).then(function (res) {
                  if (res.ok) {
                    return res.json();
                  } else {
                    return res.json().then(function (errJson) {
                                  var error = new Error("요청에 실패했습니다.");
                                  error.status = res.status;
                                  error.info = errJson;
                                  var errJson$p = errJson_decode(errJson);
                                  if (errJson$p.TAG === /* Ok */0) {
                                    error.message = errJson$p._0.message;
                                  }
                                  return Promise.reject(error);
                                }).catch(function (err) {
                                return Promise.reject(err);
                              });
                  }
                }).then(function (json) {
                return Promise.resolve(Curry._1(onSuccess, json));
              }).catch(function (err) {
              return Promise.resolve(Curry._1(onFailure, err));
            });
}

function putWithToken(url, body) {
  var accessToken = Curry._1(LocalStorageHooks.AccessToken.get, undefined);
  return fetch(url, Fetch.RequestInit.make(/* Put */3, {
                      "Content-Type": "application/json",
                      Authorization: "Bearer " + accessToken
                    }, Caml_option.some(body), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)).then(function (res) {
              if (res.ok) {
                return res.json();
              } else {
                return res.json().then(function (errJson) {
                              var error = new Error("요청에 실패했습니다.");
                              error.status = res.status;
                              error.info = errJson;
                              var errJson$p = errJson_decode(errJson);
                              if (errJson$p.TAG === /* Ok */0) {
                                error.message = errJson$p._0.message;
                              }
                              return Promise.reject(error);
                            }).catch(function (err) {
                            return Promise.reject(err);
                          });
              }
            });
}

function putWithFormData(url, formData, onSuccess, onFailure) {
  return fetch(url, Fetch.RequestInit.make(/* Put */3, undefined, Caml_option.some(formData), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)).then(function (res) {
                  if (res.ok) {
                    return Promise.resolve(res);
                  } else {
                    return res.json().then(function (errJson) {
                                  var error = new Error("요청에 실패했습니다.");
                                  error.status = res.status;
                                  error.info = errJson;
                                  var errJson$p = errJson_decode(errJson);
                                  if (errJson$p.TAG === /* Ok */0) {
                                    error.message = errJson$p._0.message;
                                  }
                                  return Promise.reject(error);
                                }).catch(function (err) {
                                return Promise.reject(err);
                              });
                  }
                }).then(function (res) {
                return Promise.resolve(Curry._1(onSuccess, res));
              }).catch(function (err) {
              return Promise.resolve(Curry._1(onFailure, err));
            });
}

function putWithFile(url, file) {
  return fetch(url, Fetch.RequestInit.make(/* Put */3, undefined, Caml_option.some(file), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)).then(function (res) {
              if (res.ok) {
                return Promise.resolve(res);
              } else {
                return res.json().then(function (errJson) {
                              var error = new Error("요청에 실패했습니다.");
                              error.status = res.status;
                              error.info = errJson;
                              var errJson$p = errJson_decode(errJson);
                              if (errJson$p.TAG === /* Ok */0) {
                                error.message = errJson$p._0.message;
                              }
                              return Promise.reject(error);
                            }).catch(function (err) {
                            return Promise.reject(err);
                          });
              }
            });
}

function putWithFileAsAttachment(url, file) {
  return fetch(url, Fetch.RequestInit.make(/* Put */3, [[
                        "Content-Disposition",
                        "attachment"
                      ]], Caml_option.some(file), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)).then(function (res) {
              if (res.ok) {
                return Promise.resolve(res);
              } else {
                return res.json().then(function (errJson) {
                              var error = new Error("요청에 실패했습니다.");
                              error.status = res.status;
                              error.info = errJson;
                              var errJson$p = errJson_decode(errJson);
                              if (errJson$p.TAG === /* Ok */0) {
                                error.message = errJson$p._0.message;
                              }
                              return Promise.reject(error);
                            }).catch(function (err) {
                            return Promise.reject(err);
                          });
              }
            });
}

function fetcher(url) {
  var accessToken = Curry._1(LocalStorageHooks.AccessToken.get, undefined);
  return fetch(url, Fetch.RequestInit.make(/* Get */0, {
                      "Content-Type": "application/json",
                      Authorization: "Bearer " + accessToken
                    }, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)).then(function (res) {
              if (res.ok) {
                return res.json();
              } else {
                return res.json().then(function (errJson) {
                              var error = new Error("요청에 실패했습니다.");
                              error.status = res.status;
                              error.info = errJson;
                              var errJson$p = errJson_decode(errJson);
                              if (errJson$p.TAG === /* Ok */0) {
                                error.message = errJson$p._0.message;
                              }
                              return Promise.reject(error);
                            }).catch(function (err) {
                            return Promise.reject(err);
                          });
              }
            });
}

function getWithToken(url, _body) {
  var accessToken = Curry._1(LocalStorageHooks.AccessToken.get, undefined);
  return fetch(url, Fetch.RequestInit.make(/* Get */0, {
                      "Content-Type": "application/json",
                      Authorization: "Bearer " + accessToken
                    }, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)).then(function (res) {
              if (res.ok) {
                return res.json();
              } else {
                return res.json().then(function (errJson) {
                              var error = new Error("요청에 실패했습니다.");
                              error.status = res.status;
                              error.info = errJson;
                              var errJson$p = errJson_decode(errJson);
                              if (errJson$p.TAG === /* Ok */0) {
                                error.message = errJson$p._0.message;
                              }
                              return Promise.reject(error);
                            }).catch(function (err) {
                            return Promise.reject(err);
                          });
              }
            });
}

function getWithTokenForExcel(url, _body) {
  var accessToken = Curry._1(LocalStorageHooks.AccessToken.get, undefined);
  return fetch(url, Fetch.RequestInit.make(/* Get */0, {
                      "Content-Type": "application/json",
                      Authorization: "Bearer " + accessToken
                    }, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)).then(function (res) {
              if (res.ok) {
                return Promise.resolve(res);
              } else {
                return res.json().then(function (errJson) {
                              var error = new Error("요청에 실패했습니다.");
                              error.status = res.status;
                              error.info = errJson;
                              var errJson$p = errJson_decode(errJson);
                              if (errJson$p.TAG === /* Ok */0) {
                                error.message = errJson$p._0.message;
                              }
                              return Promise.reject(error);
                            }).catch(function (err) {
                            return Promise.reject(err);
                          });
              }
            });
}

function getProcessedImage(url, _body) {
  return fetch(url, Fetch.RequestInit.make(/* Get */0, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)).then(function (res) {
              if (res.ok) {
                return Promise.resolve(res);
              } else {
                return Promise.reject(Js_exn.raiseError("처리된 이미지를 찾을 수 없습니다."));
              }
            });
}

function postWithToken(url, body) {
  var accessToken = Curry._1(LocalStorageHooks.AccessToken.get, undefined);
  var headers = accessToken === "" ? ({
        "Content-Type": "application/json",
        Accept: "application/json"
      }) : ({
        "Content-Type": "application/json",
        Accept: "application/json",
        Authorization: "Bearer " + accessToken
      });
  return fetch(url, Fetch.RequestInit.make(/* Post */2, Caml_option.some(headers), Caml_option.some(body), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)).then(function (res) {
              if (res.ok) {
                if (res.status === 201 || res.status === 204) {
                  return Promise.resolve(null);
                } else {
                  return res.json();
                }
              } else {
                return res.json().then(function (errJson) {
                              var error = new Error("요청에 실패했습니다.");
                              error.status = res.status;
                              error.info = errJson;
                              var errJson$p = errJson_decode(errJson);
                              if (errJson$p.TAG === /* Ok */0) {
                                error.message = errJson$p._0.message;
                              }
                              return Promise.reject(error);
                            }).catch(function (err) {
                            return Promise.reject(err);
                          });
              }
            });
}

function postWithTokenForExcel(url, body) {
  var accessToken = Curry._1(LocalStorageHooks.AccessToken.get, undefined);
  return fetch(url, Fetch.RequestInit.make(/* Post */2, {
                      "Content-Type": "application/json",
                      Authorization: "Bearer " + accessToken
                    }, Caml_option.some(body), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)).then(function (res) {
              if (res.ok) {
                return Promise.resolve(res);
              } else {
                return res.json().then(function (errJson) {
                              var error = new Error("요청에 실패했습니다.");
                              error.status = res.status;
                              error.info = errJson;
                              var errJson$p = errJson_decode(errJson);
                              if (errJson$p.TAG === /* Ok */0) {
                                error.message = errJson$p._0.message;
                              }
                              return Promise.reject(error);
                            }).catch(function (err) {
                            return Promise.reject(err);
                          });
              }
            });
}

function patchWithToken(url, body) {
  var accessToken = Curry._1(LocalStorageHooks.AccessToken.get, undefined);
  var headers = accessToken === "" ? ({
        "Content-Type": "application/json",
        Accept: "application/json"
      }) : ({
        "Content-Type": "application/json",
        Accept: "application/json",
        Authorization: "Bearer " + accessToken
      });
  return fetch(url, Fetch.RequestInit.make(/* Patch */8, Caml_option.some(headers), Caml_option.some(body), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)).then(function (res) {
              if (res.ok) {
                if (res.status === 201 || res.status === 204) {
                  return Promise.resolve(null);
                } else {
                  return res.json();
                }
              } else {
                return res.json().then(function (errJson) {
                              var error = new Error("요청에 실패했습니다.");
                              error.status = res.status;
                              error.info = errJson;
                              var errJson$p = errJson_decode(errJson);
                              if (errJson$p.TAG === /* Ok */0) {
                                error.message = errJson$p._0.message;
                              }
                              return Promise.reject(error);
                            }).catch(function (err) {
                            return Promise.reject(err);
                          });
              }
            });
}

function responseToken_encode(v) {
  return Js_dict.fromArray([
              [
                "token",
                Spice.stringToJson(v.token)
              ],
              [
                "refresh-token",
                Spice.stringToJson(v.refreshToken)
              ]
            ]);
}

function responseToken_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var token = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "token"), null));
  if (token.TAG === /* Ok */0) {
    var refreshToken = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "refresh-token"), null));
    if (refreshToken.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: {
                token: token._0,
                refreshToken: refreshToken._0
              }
            };
    }
    var e = refreshToken._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".refresh-token" + e.path,
              message: e.message,
              value: e.value
            }
          };
  }
  var e$1 = token._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".token" + e$1.path,
            message: e$1.message,
            value: e$1.value
          }
        };
}

function refreshToken(param) {
  var rt = Curry._1(LocalStorageHooks.RefreshToken.get, undefined);
  var urlSearchParams = new URLSearchParams([
          [
            "grant-type",
            "refresh-token"
          ],
          [
            "refresh-token",
            rt
          ]
        ]).toString();
  return fetch(Env.restApiUrl + "/user/token", Fetch.RequestInit.make(/* Post */2, {
                          "Content-Type": "application/x-www-form-urlencoded"
                        }, Caml_option.some(urlSearchParams), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(undefined)).then(function (res) {
                  if (res.ok) {
                    return res.json();
                  } else {
                    return res.json().then(function (errJson) {
                                  var error = new Error("요청에 실패했습니다.");
                                  error.status = res.status;
                                  error.info = errJson;
                                  var errJson$p = errJson_decode(errJson);
                                  if (errJson$p.TAG === /* Ok */0) {
                                    error.message = errJson$p._0.message;
                                  }
                                  return Promise.reject(error);
                                }).catch(function (err) {
                                return Promise.reject(err);
                              });
                  }
                }).then(function (res) {
                var result = responseToken_decode(res);
                if (result.TAG !== /* Ok */0) {
                  return Promise.reject(Js_exn.raiseError("토큰 갱신에 실패하였습니다."));
                }
                var res$1 = result._0;
                Curry._1(LocalStorageHooks.AccessToken.set, res$1.token);
                Curry._1(LocalStorageHooks.RefreshToken.set, res$1.refreshToken);
                return Promise.resolve(undefined);
              }).catch(function (err) {
              if (err.status === 400) {
                Curry._1(LocalStorageHooks.AccessToken.remove, undefined);
                Curry._1(LocalStorageHooks.RefreshToken.remove, undefined);
              }
              return Promise.reject(Js_exn.raiseError("토큰 갱신에 실패하였습니다."));
            });
}

function wait(ms) {
  return new Promise((function (resolve, reject) {
                setTimeout((function (param) {
                        return resolve(true);
                      }), ms);
                
              }));
}

function retry(errOpt, fn, count, interval) {
  var err = errOpt !== undefined ? Caml_option.valFromOption(errOpt) : undefined;
  if (count <= 0) {
    Belt_Option.forEach(err, (function (err) {
            Nextjs.captureException(err);
            
          }));
    return Promise.reject(Belt_Option.getWithDefault(err, Js_exn.raiseError("요청 재시도를 실패하였습니다.")));
  } else {
    return Curry._1(fn, undefined).catch(function (err) {
                if (err.status === 401) {
                  return refreshToken(undefined).then(function (param) {
                                return wait(interval).then(function (param) {
                                            return retry(Caml_option.some(undefined), fn, count - 1 | 0, interval);
                                          });
                              }).catch(function (err) {
                              return wait(interval).then(function (param) {
                                          return retry(Caml_option.some(err), fn, count - 1 | 0, interval);
                                        });
                            });
                } else {
                  return wait(interval).then(function (param) {
                              return retry(Caml_option.some(err), fn, count - 1 | 0, interval);
                            });
                }
              });
  }
}

function fetchWithRetry(fetcher, url, body, count) {
  return retry(Caml_option.some(undefined), (function (param) {
                return Curry._2(fetcher, url, body);
              }), count, 0);
}

function fetchWithIntervalRetry(fetcher, url, body, count, interval) {
  return retry(Caml_option.some(undefined), (function (param) {
                return Curry._2(fetcher, url, body);
              }), count, interval);
}

function relayResponse_encode(v) {
  return Js_dict.fromArray([
              [
                "data",
                Spice.optionToJson((function (v) {
                        return v;
                      }), v.data)
              ],
              [
                "errors",
                Spice.optionToJson((function (param) {
                        return Spice.arrayToJson(GraphQL.$$Error.t_encode, param);
                      }), v.errors)
              ]
            ]);
}

function relayResponse_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var data = Spice.optionFromJson((function (v) {
          return {
                  TAG: /* Ok */0,
                  _0: v
                };
        }), Belt_Option.getWithDefault(Js_dict.get(dict$1, "data"), null));
  if (data.TAG === /* Ok */0) {
    var errors = Spice.optionFromJson((function (param) {
            return Spice.arrayFromJson(GraphQL.$$Error.t_decode, param);
          }), Belt_Option.getWithDefault(Js_dict.get(dict$1, "errors"), null));
    if (errors.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: {
                data: data._0,
                errors: errors._0
              }
            };
    }
    var e = errors._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".errors" + e.path,
              message: e.message,
              value: e.value
            }
          };
  }
  var e$1 = data._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".data" + e$1.path,
            message: e$1.message,
            value: e$1.value
          }
        };
}

function relayResponseData_encode(v) {
  return Js_dict.fromArray([
              [
                "__typename",
                Spice.optionToJson((function (v) {
                        return v;
                      }), v.__typename)
              ],
              [
                "message",
                Spice.optionToJson((function (v) {
                        return v;
                      }), v.message)
              ]
            ]);
}

function relayResponseData_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var __typename = Spice.optionFromJson((function (v) {
          return {
                  TAG: /* Ok */0,
                  _0: v
                };
        }), Belt_Option.getWithDefault(Js_dict.get(dict$1, "__typename"), null));
  if (__typename.TAG === /* Ok */0) {
    var message = Spice.optionFromJson((function (v) {
            return {
                    TAG: /* Ok */0,
                    _0: v
                  };
          }), Belt_Option.getWithDefault(Js_dict.get(dict$1, "message"), null));
    if (message.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: {
                __typename: __typename._0,
                message: message._0
              }
            };
    }
    var e = message._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".message" + e.path,
              message: e.message,
              value: e.value
            }
          };
  }
  var e$1 = __typename._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".__typename" + e$1.path,
            message: e$1.message,
            value: e$1.value
          }
        };
}

function checkResponseErrorForSentry(relayResponse, body) {
  Belt_Option.forEach(relayResponse.data, (function (x) {
          var obj = Js_json.classify(x);
          if (typeof obj === "number") {
            return ;
          }
          if (obj.TAG !== /* JSONObject */2) {
            return ;
          }
          var obj$1 = obj._0;
          var resultObj = Belt_Option.flatMap(Garter_Array.first(Object.keys(obj$1)), (function (firstKey) {
                  return Js_dict.get(obj$1, firstKey);
                }));
          return Belt_Option.forEach(resultObj, (function (obj) {
                        var relayResponse = relayResponseData_decode(obj);
                        if (relayResponse.TAG !== /* Ok */0) {
                          return ;
                        }
                        var relayResponse$1 = relayResponse._0;
                        return Belt_Option.forEach(relayResponse$1.__typename, (function (__typename$p) {
                                      if (Belt_Option.mapWithDefault(Js_json.decodeString(__typename$p), false, (function (s) {
                                                return s === "Error";
                                              }))) {
                                        return Sentry.CaptureException.makeWithRelayError("RelayResponseResultError", relayResponse$1.message, body);
                                      }
                                      
                                    }));
                      }));
        }));
  return Belt_Option.forEach(Belt_Option.map(relayResponse.errors, (function (errors) {
                    return Belt_Array.keep(errors, (function (error) {
                                  return error.message !== "Unauthorized";
                                }));
                  })), (function (errors) {
                if (errors.length !== 0) {
                  return Sentry.CaptureException.makeWithRelayError("RelayError", errors, body);
                }
                
              }));
}

function fetchWithRetryForRelay(fetcher, url, body, count) {
  var fn = function (param) {
    return Curry._2(fetcher, url, body).then(function (json) {
                var relayResponse$p = relayResponse_decode(json);
                if (relayResponse$p.TAG !== /* Ok */0) {
                  return Promise.reject(Js_exn.raiseError("Cannot parse Relay response"));
                }
                var relayResponse$p$1 = relayResponse$p._0;
                if (Belt_Option.isSome(Belt_Option.flatMap(relayResponse$p$1.errors, (function (errors$p) {
                              return Belt_Array.getBy(errors$p, (function (error) {
                                            return error.message === "Unauthorized";
                                          }));
                            })))) {
                  var error = new Error("릴레이 Unauthorized");
                  error.status = 401;
                  return Promise.reject(error);
                }
                checkResponseErrorForSentry(relayResponse$p$1, body);
                return Promise.resolve(json);
              });
  };
  return retry(Caml_option.some(undefined), fn, count, 200);
}

function requestWithRetry(fetcher, url, body, count, onSuccess, onFailure) {
  return fetchWithRetry(fetcher, url, body, count).then(function (json) {
                return Promise.resolve(Curry._1(onSuccess, json));
              }).catch(function (err) {
              return Promise.resolve(Curry._1(onFailure, err));
            });
}

export {
  errJson_encode ,
  errJson_decode ,
  get ,
  post ,
  postWithURLSearchParams ,
  put ,
  putWithToken ,
  putWithFormData ,
  putWithFile ,
  putWithFileAsAttachment ,
  fetcher ,
  getWithToken ,
  getWithTokenForExcel ,
  getProcessedImage ,
  postWithToken ,
  postWithTokenForExcel ,
  patchWithToken ,
  responseToken_encode ,
  responseToken_decode ,
  refreshToken ,
  wait ,
  retry ,
  fetchWithRetry ,
  fetchWithIntervalRetry ,
  relayResponse_encode ,
  relayResponse_decode ,
  relayResponseData_encode ,
  relayResponseData_decode ,
  checkResponseErrorForSentry ,
  fetchWithRetryForRelay ,
  requestWithRetry ,
  
}
/* Env Not a pure module */
